<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Andreas Klebingers Blog - 64 Bit Words might be bigger than you think.</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/custom.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

    </head>
    <body>
        <header id="header">
            <hgroup id="logo">
                <a href="../index.html">Andreas Klebingers Blog</a>
            </hgroup>
            <nav id="navigation">
                <a href="../index.html">Home</a>
                <a href="../about.html">About</a>
                <a href="../work.html">Work with me</a>
                <a href="../archive.html">Archive</a>
                <a href="../ghc-week.html">GHC Week!</a>
            </nav>
        </header>


        <div id="content">
            <h1>64 Bit Words might be bigger than you think.</h1>

            <div class="info">
    Posted on January  4, 2026
    
        by Andreas Klebinger
    
</div>

<p>Every once in a while I’ve witnessed someone worrying about a counter overflowing.
While those bugs do certainly happen. With things that are counted one at a time
on hardware this is basically impossible.</p>
<h1 id="thesis-if-you-increment-one-at-a-time-on-hardware-a-word64-is-basically-infinite.">Thesis: If you increment one at a time, on hardware, a Word64 is basically infinite.</h1>
<p>From an engineering point of view if the hardware is guaranteed to die or your program
to terminate before you exceed 2^64 you can treat a 64bit Words as infinite. Which is
terribly convenient.</p>
<p>It’s hard to grasp how much leeway that actually gives us. So here are some examples.</p>
<h1 id="how-long-can-you-count">How long can you count?</h1>
<p>Incrementing in steps of one. How long can you count using a 64bit Word?</p>
<h2 id="cars">Cars</h2>
<p>You write a program counting cars passing by. You expect an average of one car
per second to go by. You will be able to count cars for ~40x the age of the universe.
Do not worry about it.</p>
<h2 id="cpu-cycles">CPU Cycles</h2>
<p>A average high end CPU runs at ~4GHz. If we count the number of cycles one at a
time we can count cycles for ~150 years. Don’t worry about it.</p>
<h2 id="water-drops-in-the-danube">Water drops in the Danube</h2>
<p>The danube has a throughput of ~6450m³/s. That is about 0.13 Trillion drops of
water per second. If we count each drop one at a time we can count water drops
for 43 Months. You probably don’t need to worry about it.</p>
<h2 id="photons-hitting-earth.">Photons hitting earth.</h2>
<p>It seems ~10^20 Photons hit every m² of earth every seconding. If you count them
one at a time then … wait what hardware are you running this one. Are you running
our simulation. Why is my screen turning into a matrix screen saver.</p>
<p>Jokes aside there is no hardware that could count photons hitting earth one at a
time. So don’t worry about it.</p>
<h1 id="word64-is-not-infinite">Word64 is <em>not</em> infinite</h1>
<p>Things escalate quickly if you aggregate counters. While we can count cycles
for longer than almost all hardware will last. Counting instructions on a Server
might run into roll over territory. E.g. 192 cores * 2.5GHz * 3 (IPC)
would give you a lower bound of 148 days before roll over.</p>
<p>But if you are counting things one at a time, on hardware, without adding up counters?
Don’t worry about it.</p>

        </div>
        <div id="footer">
        </div>
        <div style="display: none">If you found this and we meet tell me. I will buy you a drink.</div>
    </body>
</html>
